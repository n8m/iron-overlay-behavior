<!doctype html>
<!--
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<link rel="import" href="../polymer/polymer.html">

<script>
  (function() {
    'use strict';

    Polymer.IronFocusablesHelper = {

      /**
       * Returns a sorted array of tabbable nodes, including the root node.
       * It searches the tabbable nodes in the light and shadow dom of the chidren,
       * sorting the result by tabindex.
       * @param {!Node} node
       * @return {Array<Node>}
       */
      getTabbableNodes: function(node) {
        var result = [];
        // If there is at least one element with tabindex > 0, we need to sort
        // the final array by tabindex.
        var needsSortByTabIndex = this._collectTabbableNodes(node, result);
        if (needsSortByTabIndex) {
          result.sort(this._tabIndexSort);
        }
        return result;
      },

      /**
       * Returns if a node is focusable.
       * @param {!Node} node
       * @return {boolean}
       */
      isFocusable: function(node) {
        // From http://stackoverflow.com/a/1600194/4228703:
        // There isn't a definite list, it's up to the browser. The only
        // standard we have is DOM Level 2 HTML https://www.w3.org/TR/DOM-Level-2-HTML/html.html,
        // according to which the only elements that have a focus() method are
        // HTMLInputElement,  HTMLSelectElement, HTMLTextAreaElement and
        // HTMLAnchorElement. This notably omits HTMLButtonElement and
        // HTMLAreaElement.
        // Referring to these tests with focusables in different browsers
        // http://allyjs.io/data-tables/focusable.html

        // shadow roots won't have this method.
        if (!node.hasAttribute) {
          return false;
        }
        var name = node.localName;
        // These elements cannot be focused if they have [disabled] attribute.
        if (/^(input|select|textarea|button|object)$/.test(name)) {
          return !node.disabled;
        }
        // These elements can be focused even if they have [disabled] attribute.
        return name === 'iframe' ||
          (/^(a|area)$/.test(name) && node.hasAttribute('href')) ||
          node.hasAttribute('tabindex') ||
          node.hasAttribute('contenteditable');
      },

      /**
       * Returns if a node is tabbable. To be tabbable, a node must be focusable
       * and visible.
       * @param {!Node} node
       * @return {boolean}
       */
      isTabbable: function(node) {
        return this._normalizedTabIndex(node) >= 0 && this._isVisible(node);
      },

      /**
       * Returns the normalized node tabindex. If not focusable, returns -1.
       * It checks for the attribute "tabindex" instead of the element property
       * `tabIndex` since browsers assign different values to it.
       * e.g. for <div id="elem" contenteditable>
       * `elem.tabIndex` is `-1` in Firefox, `0` in other browsers.
       * @param {!Node} node
       * @return {Number}
       * @private
       */
      _normalizedTabIndex: function(node) {
        if (this.isFocusable(node)) {
          var tabIndex = node.getAttribute('tabindex') || 0;
          return Number(tabIndex);
        }
        return -1;
      },

      /**
       * Searches for nodes that are tabbable and adds them to the `result` array.
       * Returns if the `result` array needs to be sorted by tabindex.
       * @param {!Node} node The starting point for the search; added to `result`
       * if tabbable.
       * @param {!Array<Node>} result
       * @return {boolean}
       * @private
       */
      _collectTabbableNodes: function(node, result) {
        // Skip #text nodes. If not visible, no need to explore children.
        if (node.nodeType === 3 || !this._isVisible(node)) {
          return false;
        }
        var tabIndex = this._normalizedTabIndex(node);

        // TODO(valdrin) uncomment this when delegatesFocus is implemented.
        // if delegatesFocus and tabindex = -1, should skip its children.
        // if (tabIndex < 0 && node.delegatesFocus) {
        //   return false;
        // }

        var needsSortByTabIndex = tabIndex > 0;
        if (tabIndex >= 0) {
          result.push(node);
        }

        var children;
        if (node.localName === 'content') {
          children = Polymer.dom(node).getDistributedNodes();
        } else {
          // Use shadow root if possible, will check for distributed nodes.
          children = Polymer.dom(node.root || node).children;
        }
        for (var i = 0; i < children.length; i++) {
          // Ensure method is always invoked to collect tabbable children.
          var needsSort = this._collectTabbableNodes(children[i], result);
          needsSortByTabIndex = needsSortByTabIndex || needsSort;
        }
        return needsSortByTabIndex;
      },

      /**
       * Returns false if the node has `visibility: hidden` or `display: none`
       * @param {!Node} node
       * @return {boolean}
       * @private
       */
      _isVisible: function(node) {
        // Check inline style first to save a re-flow. If looks good, check also
        // computed style.
        if (node.style.visibility !== 'hidden' && node.style.display !== 'none') {
          var style = window.getComputedStyle(node);
          return (style.visibility !== 'hidden' && style.display !== 'none');
        }
        return false;
      },

      /**
       * Sort by tabindex. Move elements with tabindex = 0 to the end to match
       * browser behavior, e.g. [0, 3, 1, 2] --> [1, 2, 3, 0]
       * @param {!Node} a
       * @param {!Node} b
       * @return {Number}
       * @private
       */
      _tabIndexSort: function(a, b) {
        // Move tabindex = 0 elements to the end of the list.
        if (a.tabIndex === 0 || b.tabIndex === 0) {
          // The one with bigger `tabindex` goes on top of the list.
          return b.tabIndex - a.tabIndex;
        }
        // The one with smaller `tabindex` goes on top of the list.
        return a.tabIndex - b.tabIndex;
      }
    };
  })();
</script>
